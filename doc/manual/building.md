Building {#building}
========

The IMP build system is has many parts, some implemented in Python, some in CMake and some autogenerated. Pieces of IMP are built either when CMake is run or when ninja is run.

## When CMake is Run

As a general rule, anything which depends only on the set of files in IMP (and not their contents) should be done when CMake is run. There are several main steps:
- `setup_git.py` is run in order to make sure all subrepositories are initialized and up to date. IMP pulls in external subrepositories for things like RMF (`modules/rmf/dependency/RMF_source`), cmake modules (within RMF), developer tools (also within RMF). These allow those repositories to be used elsewhere. For example, any module not in the IMP repository can use the git hooks that IMP uses by adding a `setup_git.py` and adding developer_tools subrepository.
- `tools/dev_tools/setup_cmake.py` is run to generate the current lists of files in the repository. These lists go (roughly) in every directory named `include`, `src`, or `bin` and list all python and C++ files. CMake reads these lists and uses them to figure out what to build. These generated files, called `Files.cmake` are ignored by `git`.
- `tools/build/setup_cmake.py` generates the autogenerated  `CMakeLists.txt` files for each module and application. These are also ignored by `git` and should not be modified by users. Instead, users can put module-specific code in `modules/modulename/Setup.cmake`.
- dependencies are checked and modules are enabled and disabled. For various reasons, this involves both the setting of cmake variables and the writing of files to `data/build` in the build directory. Ultimate, these should probably all move to `cmake`, but having the split smoothed the transition from `scons`.
- The various all headers are generated using `tools/dev_tools/make_all_header.py`. These headers list all the headers necessary for a given module and greatly simply the swig files (which have to include all these headers).
- The swig wrapper files are generated using `tools/build/setup_swig.py`. These files include all the necessary all headers as well as include the corresponding `swig.i-in` files. Each module must include all the things necessary for all its dependencies, so maintaining these files is nontrivial.
- The swig dependencies are computed using `tools/build/setup_swig_dependencies.py`. Generating the dependencies is quite expensive so it is only done at cmake time, using as many threads as possible. In order to get this right, autogenerated headers such as the container headers (`tools/build/make_containers.py`) are generated during cmake (they are also generated when ninja is run).
- Standards test are generated. These should be generated when ninja is run (or rewritten to read the exceptions list at runtime). But they aren't.

## When ninja is run
In addition to the normal compilation and things. The following build targets exist in IMP
- container files are generated
