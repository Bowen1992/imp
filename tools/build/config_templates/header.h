/*
 * \file %(filename)s
 * \brief Provide macros to mark functions and classes as exported
 *        from a DLL/.so, and to set up namespaces
 *
 * When building the module, %(cppprefix)s_EXPORTS should be defined, and when
 * using the module externally, it should not be. Classes and functions
 * declared in the module's headers should then be marked with
 * %(cppprefix)sEXPORT if they are intended to be part of the API and
 * they are not defined entirely in a header.
 *
 * The Windows build environment requires applications to mark exports in
 * this way; we use the same markings to set the visibility of ELF symbols
 * if we have compiler support.
 *
 * All code in this module should live in the IMP::%(name)s namespace.
 * This is simply achieved by wrapping things with the
 * %(cppprefix)s_BEGIN_NAMESPACE and %(cppprefix)s_END_NAMESPACE macros.
 * There are similar macros for module code that is designed to be for
 * internal use only.
 *
 * This header is auto-generated by tools/build/setup_module.py;
 * it should not be edited manually.
 *
 * Copyright 2007-2013 IMP Inventors. All rights reserved.
 *
 */

#ifndef %(cppprefix)s_CONFIG_H
#define %(cppprefix)s_CONFIG_H

#include <IMP/base/base_config.h>
#include <string>


#ifdef _MSC_VER

#ifdef %(cppprefix)s_EXPORTS
#define %(cppprefix)sEXPORT __declspec(dllexport)
#else // EXPORTS
#define %(cppprefix)sEXPORT __declspec(dllimport)
#endif // EXPORTS

#else // _MSC_VER

#ifdef GCC_VISIBILITY
#define %(cppprefix)sEXPORT __attribute__ ((visibility("default")))
#else // GCC_VISIBILITY
#define %(cppprefix)sEXPORT
#endif // GCC_VISIBILITY
#endif // _MSC_VER

#if defined(_MSC_VER) && !defined(SWIG)
#ifdef %(cppprefix)s_EXPORTS

#define %(cppprefix)s_EXPORT_TEMPLATE(name)                 template class __declspec(dllexport) name

#else //EXPORTS

#define %(cppprefix)s_EXPORT_TEMPLATE(name)                 template class __declspec(dllimport) name

#endif // EXPORTS

#else // MSC and SWIG
#define %(cppprefix)s_EXPORT_TEMPLATE(name) IMP_REQUIRE_SEMICOLON_NAMESPACE

#endif // MSC and SWIG

#if !defined(SWIG) && !defined(IMP_DOXYGEN)

#define %(cppprefix)s_BEGIN_NAMESPACE \
IMP_COMPILER_ENABLE_WARNINGS \
namespace IMP { namespace %(name)s { \

#define %(cppprefix)s_END_NAMESPACE \
} } \
IMP_COMPILER_DISABLE_WARNINGS

#define %(cppprefix)s_BEGIN_INTERNAL_NAMESPACE \
%(cppprefix)s_BEGIN_NAMESPACE namespace internal {


#define %(cppprefix)s_END_INTERNAL_NAMESPACE \
} %(cppprefix)s_END_NAMESPACE

#else
#define %(cppprefix)s_BEGIN_NAMESPACE \
namespace IMP { namespace %(name)s {

#define %(cppprefix)s_END_NAMESPACE \
} }

#define %(cppprefix)s_BEGIN_INTERNAL_NAMESPACE \
%(cppprefix)s_BEGIN_NAMESPACE namespace internal {


#define %(cppprefix)s_END_INTERNAL_NAMESPACE \
} %(cppprefix)s_END_NAMESPACE

#endif

%(cppdefines)s

//  functions are defined explicitly for swig

namespace IMP { namespace %(name)s {
/** \name Standard module methods
  All \imp modules have a set of standard methods to help get information
  about the module and about files associated with the module.
  @{
  */
#if !defined(SWIG)
%(cppprefix)sEXPORT std::string get_module_version();
#endif

#if !defined(SWIG)
// swig will whine about duplicate definitions of function
inline std::string get_module_name() {
   return "IMP::%(name)s";
}
#endif

} } //namespace

%(showable)s

#if !defined(SWIG)

namespace IMP { namespace %(name)s {

//! Return the full path to installed data
/** Each module has its own data directory, so be sure to use
    the version of this function in the correct module. To read
    the data file "data_library" that was placed in the \c data
    directory of module "mymodule", do something like
    \code
    std::ifstream in(IMP::mymodule::get_data_path("data_library"));
    \endcode
    This will ensure that the code works when \imp is installed or
    used via the \c setup_environment.sh script.
*/
%(cppprefix)sEXPORT std::string get_data_path(std::string file_name);

//! Return the path to installed example data for this module
/** Each module has its own example directory, so be sure to use
    the version of this function in the correct module.  For example
    to read the file \c example_protein.pdb located in the
    \c examples directory of the IMP::atom module, do
    \code
    IMP::atom::read_pdb(IMP::atom::get_example_path("example_protein.pdb", model));
    \endcode
    This will ensure that the code works when \imp is installed or
    used via the \c setup_environment.sh script.
*/
%(cppprefix)sEXPORT std::string get_example_path(std::string file_name);
/** @} */


} } // namespace

#endif // SWIG

#include <IMP/base/compiler_macros.h>

#ifdef IMP_DOXYGEN
/** \namespace IMP::%(name)s
    \brief See [main page](index.html) for more information.
    */
#endif

#endif  /* %(cppprefix)s_CONFIG_H */
